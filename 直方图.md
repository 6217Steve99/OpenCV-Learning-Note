图像直方图是对数据集合的一种统计方法，将统计结果分布于一系列预定义的bin中，bin 是直方图中经常用到的一个概念，其数值是从数据中计算出的特征统计量，这些数据不仅仅指的灰度值，统计数据可能是任何能有效描述图像的特征包括梯度、方向、色彩或任何其他特征。直方图获得的是数据分布的统计图，通常直方图的维数要低于原始数据。

图像直方图是用以表示数字图像中亮度分布的直方图，标绘了图像中亮度值的像素数。可以借助观察该直方图了解需要如何调整亮度分布，这种直方图中横坐标的左侧为纯黑或较暗区域，右侧为较亮纯白的区域。因此一张较暗图片的图像直方图中数据多集中于左侧和中间部分，而整体明亮、只有少量阴影的图像则相反。计算机视觉领域长借助图像直方图来实现图像的二值化。直方图意义如下：

- 直方图是图像中像素强度分布的图形表达方式。
- 它统计了每个强度值所具有的像素个数。



- dims: 需要统计的特征的数据，上面的例子中，dims=1因为我们仅仅统计了灰度值(灰度图像)
- bins:每个特征空间子区段的数据，上面的例子中bins=16
- range: 每个特征空间的取值范围，在上面的例子中range=[0,255]

如果想统计两个特征，直方图就由上面的二维扩展为三维，x轴和y轴分别代表一个特征，z轴是再bin区间的样本数据，同样的方法适用于更多多维度的情况。



在 OpenCV 中提供了 `cv::calcHist()` 方法计算图像的直方图，计算完成后可以采用 OpenCV 中的绘图函数如`cv::rectangle`、`cv::line` 等绘制显示出来。

`cv::calcHist()`函数原型如下：

```c++
void cv::calcHist ( 
    const Mat *     images,
    int     nimages,
    const int *     channels,
    InputArray      mask,
    OutputArray     hist,
    int     dims,
    const int *     histSize,
    const float **      ranges,
    bool    uniform = true,
    bool    accumulate = false 
) 
```

- images：输入的图像或数组，它们的深度必须为 `CV_8U`, `CV_16U` 或 `CV_32F` 中的一类，尺寸必须相同
- nimages：输入数组个数，也就是第一个参数中存放了几张图像，有几个原数组。
- channels：需要统计的通道 dim，第一个数组通道从0到 image[0].channels()-1，第二个数组从image[0].channels()到images[0].channels()+images[1].channels()-1，以后的数组以此类推
- mask：可选的操作掩码。如果此掩码不为空，那么它必须为8位并且尺寸要和输入图像一致。非零掩码用于标记出统计直方图的数组元素数据。如果无需掩码可使用 `cv::Mat()` 作为参数
- hist: 输出的目标直方图，一个二维数组
- dims：需要计算直方图的维度，必须是正数且并不大于 `CV_MAX_DIMS`（在OpenCV中等于32）
- histSize：每个维度的直方图尺寸的数组
- ranges：每个维度中bin的取值范围
- uniform：直方图是否均匀的标识符，有默认值true
- accumulate：累积标识符，有默认值false,若为true，直方图再分配阶段不会清零。此功能主要是允许从多个阵列中计算单个直方图或者用于再特定的时间更新直方图



大多数情况下，直方图是单个的单通道或三通道图像，但也可以在这个函数中指定一个分布在多幅图像（即多个 `cv::Mat`）上的多通道图像。这也是把输入图像数组作为函数第一个参数的原因。第六个参数 dims 指明了直方图的维数， 例如 1 表示一维直方图。在分析多通道图像时，可以只把它的部分通道用于计算直方图，将需要处理的通道放在维数确定的数组 channel 中。直方图用每个维度上的箱子数量（即整数数组 histSize）以及每个维度（由 ranges 数组提供，数组中每个元素又是一个二元素数组）上的最小值（含）和最大值（不含）来描述。你也可以定义一个不均匀的直方图（倒数第二个参数应设为 false），这时需要指定每个箱子的限值。和很多 OpenCV 函数一样，可以使用掩码表示计算时用到的像素（所有掩码值为 0 的像素都不使用）。此外还可以指定两个布尔值类型的附加参数，第一个表示是否采用均匀的直方图（默认为 true），第二个表示是否允许累加多个直方图计算的结果。如果第二个参数为 true，那么图像中的像素数量会累加到输入直方图的当前值中。在计算一组图像的直方图时，就可以使用这个参数。得到的直方图存储在 cv::Mat 的实例中。事实上，cv::Mat 类可用于操作通用的 N 维矩阵。
cv::Mat 类定义了适用于一维、二维和三维矩阵的 at 方法。我们可以用下面的代码访问一维直方图的每个箱子：

```c++
float binVal = hist.at<float>(h);
```


注意，直方图中的值存储为 float 值。



这里的 hist 对象是一个一维数组，包含 256 个项目。因此只需遍历这个数组，就可以读取每个 bin 的数据。



在计算图像直方图的时候一般配合 `cv::minMaxLoc()`和 `cv::normalize()`函数，`cv::minMaxLoc()`函数是用于寻找最值的函数，其定义如下：

```c++
void cv::minMaxLoc  (   
    InputArray      src,
    double *    minVal,
    double *    maxVal = 0,
    Point *     minLoc = 0,
    Point *     maxLoc = 0,
    InputArray   mask = noArray()
)
```

- src：输入的单通道数组
- minVal：double类型指针，用于返回最小值的指针，如果不需要返回则设置为NULL
- maxVal：double类型的指针，用于返回最大值指针，如果不需要返回则设置为NULL
- minLoc：返回最小值位置指针（2D的情况下），如果不需要则设置为NULL
- maxLoc：返回最大位置指针（2D情况下），如果不需要则设置为NULL
- mask：可选掩模板。



`cv::normalize()` 函数的作用是将一个数组的值归一化到指定的范围

```c++
void cv::normalize ( 
    InputArray      src,
    InputOutputArray  dst,
    double         alpha = 1,
    double         beta = 0,
    int           norm_type = NORM_L2,
    int           dtype = -1,
    InputArray      mask = noArray() 
)
```

- src：输入数组
- dst：输出数组，与src有相同的尺寸
- alpha：将数组归一化范围的最大值，有默认值1
- beta：归一化的最小值，有默认值0
- norm_type：归一化方式，可以查看 `NormTypes()` 函数查看详细信息，有默认值 `NORM_L2`
- dtype：当该值取负数时，输出数组与 src 有相同类型，否则，与 src 有相同的通道并且深度为 `CV_MAT_DEPTH(dtype)`
- mask：可选的掩模版



在得到直方图数组之后，就可以使用 `cv::line` 函数将其绘制出来了，`cv::line`的函数原型如下：

```c++
void cv::line( 
    InputOutputArray    img, 
    cv::Point         pt1, 
    cv::Point         pt2, 
    const cv::Scalar &   color, 
    int             thickness=1, 
    int             line_type=8, 
    int             shift=0 
)
```

- img: 要绘制线段的图像。
- pt1: 线段的起点。
- pt2: 线段的终点。
- color: 线段的颜色，通过一个Scalar对象定义。
- thickness: 线条的宽度。
- lineType: 线段的类型。可以取值8、4和 `CV_AA`， 分别代表8邻接连接线，4邻接连接线和反锯齿连接线。默认值为8邻接。为了获得更好地效果可以选用 `CV_AA`（采用了高斯滤波）。
- shift: 坐标点小数点位数。





直方图绘制的主体代码：

```c++
// 计算一维直方图，并返回它的图像
cv::Mat getHistogramImage(const cv::Mat &image, int zoom=1) {
    // 先计算直方图
    cv::Mat hist= getHistogram(image);
    // 创建图像
    return getImageOfHistogram(hist, zoom);
}

// 创建一个表示直方图的图像（静态方法）
static cv::Mat getImageOfHistogram (const cv::Mat &hist, int zoom) {
    // 取得箱子值的最大值和最小值
    double maxVal = 0;
    double minVal = 0;
    cv::minMaxLoc(hist, &minVal, &maxVal, 0, 0);
    
    // 取得直方图的大小
   int histSize = hist.rows;
    // 用于显示直方图的方形图像
    cv::Mat histImg(histSize*zoom, histSize*zoom,CV_8U, cv::Scalar(255));
    // 设置最高点为 90%（即图像高度）的箱子个数
    int hpt = static_cast<int>(0.9*histSize);
    // 为每个箱子画垂直线
    for (int h = 0; h < histSize; h++) {
        float binVal = hist.at<float>(h);
        if (binVal>0) {
            int intensity = static_cast<int>(binVal*hpt / maxVal);
            cv::line(histImg, cv::Point(h*zoom, histSize*zoom),
                     cv::Point(h*zoom, (histSize - intensity)*zoom),
                     cv::Scalar(0), zoom);
        }
    }
    return histImg;
}
```







原图：

![groupBW](E:\Codes\Opencv\Opencv 第四章\Opencv模板\groupBW.jpg)

直方图：

![Histogram](E:\Codes\Opencv\Opencv 第四章\Opencv模板\Histogram.jpg)





从上面图形化的直方图可以看出，在中等灰度值处有一个大的尖峰，并且比中等值更黑的像素有很多。而该图像有一个很明显的特点，就是前景和背景的灰度差距非常大，因此有些时候也可以根据灰度的差别实现快速的图像分割。在这两部分的汇合处进行阈值化处理就可以实现该功能。 OpenCV 中的 `cv::threshold` 函数可以实现这个功能。取直方图中在升高为尖峰之前的最小值的位置（灰度值为 70）（最长的竖线的位置），对其进行阈值化处理，得到二值图像

![Binary Image](E:\Codes\Opencv\Opencv 第四章\Opencv模板\Binary Image.jpg)

```c++
cv::Mat thresholded; // 输出二值图像
cv::threshold(image,thresholded,70, // 阈值
						255, // 对超过阈值的像素赋值
						cv::THRESH_BINARY); // 阈值化类型
```

这个阈值也可以根据图像具体情况自己手动调整



## 计算彩色直方图

我们可以用同一个 cv::calcHist 函数计算多通道图像的直方图。例如，若想计算彩色 BGR
图像的直方图，可以这样定义一个类：

```c++
class ColorHistogram {
    private:
    int histSize[3]; // 每个维度的大小
    float hranges[2]; // 值的范围（三个维度用同一个值）
    const float* ranges[3]; // 每个维度的范围
    int channels[3]; // 需要处理的通道
    public:
    ColorHistogram() {
        // 准备用于彩色图像的默认参数
        // 每个维度的大小和范围是相等的
        histSize[0]= histSize[1]= histSize[2]= 256;
        hranges[0]= 0.0; // BGR 范围为 0~256
        hranges[1]= 256.0;
        ranges[0]= hranges; // 这个类中
        ranges[1]= hranges; // 所有通道的范围都相等
        ranges[2]= hranges;
        channels[0]= 0; // 三个通道： B
        channels[1]= 1; // G
        channels[2]= 2; // R
    }
```

这里的直方图将会是三维的，因此需要为每个维度指定一个范围。准备好参数后，就可以用下面的方法计算颜色直方图了：

```c++
// 计算直方图
cv::Mat getHistogram(const cv::Mat &image) {
    cv::Mat hist;
    // 计算直方图
    cv::calcHist(&image, 1, // 单幅图像的直方图
                 channels, // 用到的通道
                 cv::Mat(), // 不使用掩码
                 hist, // 得到的直方图
                 3, // 这是一个三维直方图
                 histSize, // 箱子数量
                 ranges // 像素值的范围
                );
    return hist;
}
```

上述方法返回一个三维的 `cv::Mat` 实例。如果选用含有 256 个箱子的直方图，这个矩阵就有 $256^3$ 个元素，表示超过 1600 万个项目。在很多应用程序中，最好在计算直方图时减少箱子的数量。也可以使用数据结构 `cv::SparseMat` 表示大型稀疏矩阵，这样不会消耗过多的内存。 cv::calcHist 函数具有返回这种矩阵的版本，因此只需要简单地修改一下前面的方法，即可使用 `cv::SparseMatrix`：

```c++
// 计算直方图
cv::SparseMat getSparseHistogram(const cv::Mat &image) {
    cv::SparseMat hist(
        3, // 维数
        histSize, // 每个维度的大小
        CV_32F);
    // 计算直方图
    cv::calcHist(&image, 1, // 单幅图像的直方图
                 channels, // 用到的通道
                 cv::Mat(), // 不使用掩码
                 hist, // 得到的直方图
                 3, // 这是三维直方图
                 histSize, // 箱子数量
                 ranges // 像素值的范围
                );
    return hist;
}
```



## 利用查找表修改图像外观

查找表是个一对一（或多对一）的函数，定义了如何把像素值转换成新的值。它是一个一维数组，对于规则的灰度图像，它包含 256 个项目。

```c++
// 输出图像
cv::Mat result;
// 应用查找表
cv::LUT(image,lookup,result);
```



所谓的查找表，更通俗的讲就是一个用于对照的表，比如 `lookup[i]=x;`，i就是原来的像素值，而 x 表示的就是对应像素值映射出的新的值。一般情况下，我们先根据需要设计一个查找表，然后利用 `cv::LUT` 函数进行变换，这样就可以得到应用查找表修改之后的图像。



`cv::LUT` 函数原型如下：

```c++
void cv::LUT(InputArray src, InputArray lut, OutputArray dst);
//src表示的是输入图像(可以是单通道也可是3通道)
//lut表示查找表（查找表也可以是单通道，也可以是3通道，如果输入图像为单通道，那查找表必须为单通道，若输入图像为3通道，查找表可以为单通道，也可以为3通道，若为单通道则表示对图像3个通道都应用这个表，若为3通道则分别应用 ）
//dst表示输出图像
```



查找表有很大的作用，最明显的就是，使针对于像素颜色值的操作更加简便与快捷。利用查找表我们可以将实际采样到的像素灰度值经过一定的变换如阈值、反转、二值化、对比度调整、线性变换等，变成了另外一个与之对应的灰度值，这样可以起到突出图像的有用信息，增强图像的光对比度的作用，或者压缩图像。



对于需要更换全部像素强度值的程序，都可以使用查找表。但是这个转换过程必须是针对整幅图像的。也就是说，一个强度值对应的全部像素都必须使用同一种转换方法。



这里我们举个例子，比如说图中根本没有大于 200 的像素值，那么我们就可以通过映射在保证分布曲线不变的情况下将强度值重新映射到更大的范围中，从而通过伸展直方图来生成一个对比度更高的图像。



```c++
// 像素的百分比
float number= image.total()*percentile;
// 找到直方图的左极限
int imin = 0;
for (float count=0.0; imin < 256; imin++) {
    // 小于或等于 imin 的像素数量必须>number
    if ((count+=hist.at<float>(imin)) >= number)
        break;
}
// 找到直方图的右极限
int imax = 255;
for (float count=0.0; imax >= 0; imax--) {
    // 大于或等于 imax 的像素数量必须> number
    if ((count += hist.at<float>(imax)) >= number)
        break;
}
```

然后重新映射强度值，使 imin 的值变成强度值 0， imax 的值变成强度值 255。两者之间的 i 进行线性映射的计算式为：
`255.0*(i-imin)/(imax-imin);`





### 在彩色图像上应用查找表

之前我们曾经设计了减色函数，通过修改图像中的 BGR 值减少可能的颜色数量。当时的实现方法是循环遍历图像中的像素，并对每个像素应用减色函数。实际上，更高效的做法是预先计算好所有的减色值，然后用查找表修改每个像素。利用本节的方法，这很容易实现。下面是新的减色函数：

```c++
void colorReduce(cv::Mat &image, int div=64) {
    // 创建一维查找表
    cv::Mat lookup(1,256,CV_8U);
    // 定义减色查找表的值
    for (int i=0; i<256; i++)
        lookup.at<uchar>(i)= i/div*div + div/2;
    // 对每个通道应用查找表
    cv::LUT(image,lookup,image);
}
```

这种减色方案之所以能起作用，是因为在多通道图像上应用一维查找表时，同一个查找表会独立地应用在所有通道上。如果查找表超过一个维度，那么它和所用图像的通道数必须相同。





### 直方图均衡化

上面我们介绍了一种增强图像对比度的方法，即通过伸展直方图，使它布满可用强度值的全部范围。这方法确实可以简单有效地提高图像质量，但很多时候，图像的视觉缺陷并不因为它使用的强度值范围太窄，而是因为部分强度值的使用频率远高于其他强度值。 之前显示的直方图就是此类现象的一个很好的例子——中等灰度的强度值非常多，而较暗和较亮的像素值则非常稀少。

因此，均衡对所有像素强度值的使用频率可以作为提高图像质量的一种手段。这正是直方图均衡化这一概念背后的思想，也就是让图像的直方图尽可能地平稳。


OpenCV 提供了一个易用的函数，用于直方图均衡化处理。这个函数的原型为：

```c++
cv::equalizeHist(image,result);
```







对图像应用该函数后，得到的结果如下所示。

![Equalized Image](E:\Codes\Opencv\Opencv 第四章\Opencv模板\Equalized Image.jpg)

因为查找表是针对整幅图像的多对一的转换过程，所以直方图是不能做到完全平稳的。
但是可以看出，直方图的整体分布情况已经比原来均衡多了。

![Equalized H](E:\Codes\Opencv\Opencv 第四章\Opencv模板\Equalized H.jpg)



在一个完全均衡的直方图中，所有箱子所包含的像素数量是相等的。这意味着 50%像素的强度值小于 128（强度中值）， 25%像素的强度值小于 64，以此类推。这个现象可以用一条规则来表示： $p\%$ 像素的强度值必须小于或等于 $255*p\%$。这条规则用于直方图均衡化处理，表示强度值 i 的映像对应强度值小于 i 的像素所占的百分比。因此可以用下面的语句构建所需的查找表：

```c++
lookup.at<uchar>(i)= static_cast<uchar>(255.0*p[i]/image.total());
```


这里的 p[i]是强度值小于或等于 i 的像素数量，通常称为累计直方图。这种直方图包含小于或等于指定强度值的像素数量，而非仅仅包含等于指定强度值的像素数量。image.total() 返回图像的像素总数，因此 p[i]/image.total() 就是像素数量的百分比。



一般来说，直方图均衡化会大大改进图像外观，但是改进的效果会因图像可视内容的不同而不同。



### 反向投影直方图检测特定图像内容

直方图是图像内容的一个重要特性。如果图像的某个区域含有特定的纹理或物体，这个区域的直方图就可以看作一个函数，该函数返回某个像素属于这个特殊纹理或物体的概率。下面将介绍如何运用直方图反向投影的概念方便地检测特定的图像内容。



假设你希望在某幅图像中检测出特定的内容（例如检测出下图中天上的云彩），首先要做的就是选择一个包含所需样本的感兴趣区域。下图中的该区域就在矩形内部。



在程序中用下面的方法可以得到这个感兴趣区域：

```c++
cv::Mat imageROI;
imageROI= image(cv::Rect(216,33,24,30)); // 云彩区域
```

![Image2](E:\Codes\Opencv\Opencv 第四章\Opencv模板\Image2.jpg)

接着提取该 ROI 的直方图。通过归一化直方图，我们可得到一个函数，由此可得到特定强度值的像素属于这个区域的概率：

```c++
cv::normalize(histogram,histogram,1.0);
```

反向投影直方图的过程包括：从归一化后的直方图中读取概率值并把输入图像中的每个像素替换成与之对应的概率值。 



OpenCV 中有一个函数可完成此任务：

```c++
cv::calcBackProject(
    &image,
    1, // 一幅图像
    channels, // 用到的通道，取决于直方图的维度
    histogram, // 需要反向投影的直方图
    result, // 反向投影得到的结果
    ranges, // 值的范围
    255.0   // 选用的换算系数
          // 把概率值从 1 映射到 255
);
```

`cv::calBackProject` 函数和 `cv::calcHist` 有些类似。一个像素的值对应直方图的一个箱子（可能是多维的）。但 `cv::calBackProject` 不会增加箱子的计数，而是把从箱子读取的值赋给反向投影图像中对应的像素。函数的第一个参数指明输入的图像（通常只有一个），接着需要指明使用的通道数量。这里传递给函数的直方图是一个输入参数，它的维度数要与通道列表数组的维度数一致。与 cv::calcHist 函数一样，这里的 ranges 参数用数组形式指定了输入直方图的箱子边界。该数组以浮点数组为元素，每个数组元素表示一个通道的取值范围（最小值和最大值）。



输出结果是一幅图像，包含计算得到的概率分布图。由于每个像素已经被替换成直方图中对应箱子处的值，因此输出图像的值范围是 0.0~1.0（假定输入的是归一化直方图）。最后一个参数是换算系数，可用来重新缩放这些值。



得到的结果就是下面的概率分布图。为提高可读性，对图像做了反色处理，属于该区域的概率从亮（低概率）到暗（高概率），如下所示。

![Backprojection result](E:\Codes\Opencv\Opencv 第四章\Opencv模板\Backprojection result.jpg)

如果对此图做阈值化处理，就能得到最有可能是“云彩”的像素：

```c++
cv::threshold(result, result, threshold, 255, cv::THRESH_BINARY);
```


得到的结果如下所示。

![Detection Result](E:\Codes\Opencv\Opencv 第四章\Opencv模板\Detection Result.jpg)

前面的结果并不令人满意。因为除了云彩，其他区域也被错误地检测到了。这个概率函数是从一个简单的灰度直方图提取的，理解这点很重要。很多其他像素的强度值与云彩像素的强度值是相同的，在对直方图进行反向投影时会用相同的概率值替换具有相同强度值的像素。有一种方案可提高检测效果，那就是使用色彩信息。要实现这点，需改变对 `cv::calBackProject` 的调用方式。



反向映射颜色直方图多维度直方图也可以在图像上进行反向映射。我们定义一个封装反向映射过程的类，首先定义必需的参数并初始化：



```c++
class ContentFinder {
    private:
    // 直方图参数
    float hranges[2];
    const float* ranges[3];
    int channels[3];
    float threshold; // 判断阈值
    cv::Mat histogram; // 输入直方图
    
    public:
    ContentFinder() : threshold(0.1f) {
        // 本类中所有通道的范围相同
        ranges[0]= hranges;
        anges[1]= hranges;
        ranges[2]= hranges;
}
```



这里引入了一个阈值参数，用于创建显示检测结果的二值分布图。如果这个参数设为负数，就会返回原始的概率分布图。输入的直方图用下面的方法归一化（但这不是必须的）：

```c++
// 设置引用的直方图
void setHistogram(const cv::Mat& h) {
    histogram= h;
    cv::normalize(histogram,histogram,1.0);
}
```



要反向投影直方图，只需指定图像、范围（这里假定所有通道的范围是相同的）和所用通道的列表。方法 find 可以进行反向投影。它有两个版本，一个使用图像的三个通道，并调用通用版本的方法：

```c++
// 使用全部通道，范围[0,256]
cv::Mat find(const cv::Mat& image) {
    cv::Mat result;
    hranges[0]= 0.0; // 默认范围[0,256]hranges[1]= 256.0;
    channels[0]= 0; // 三个通道
    channels[1]= 1;
    channels[2]= 2;
    return find(image, hranges[0], hranges[1], channels);
}

// 查找属于直方图的像素
cv::Mat find(const cv::Mat& image, float minValue,float maxValue,int *channels) {
    cv::Mat result;
    hranges[0]= minValue;
    hranges[1]= maxValue;
    // 直方图的维度数与通道列表一致
    for (int i=0; i<histogram.dims; i++)
        this->channels[i]= channels[i];
    cv::calcBackProject(
        &image, 
        1, // 只使用一幅图像
        channels, // 通道
        histogram, // 直方图
        result, // 反向投影的图像
        ranges, // 每个维度的值范围
        255.0   // 选用的换算系数
              // 把概率值从 1 映射到 255
    );
}
// 对反向投影结果做阈值化，得到二值图像
if (threshold>0.0)
    cv::threshold(result, result,255.0*threshold,
                  255.0, cv::THRESH_BINARY);
return result;
```

现在把前面用过的图像换成彩色版本，并使用一个 BGR 直方图。这次来检测天空区域。首先装载彩色图像，定义 ROI，然后计算经过缩减的色彩空间上的3D 直方图，代码如下所示：

```c++
// 装载彩色图像
ColorHistogram hc;
cv::Mat color= cv::imread("waves.jpg");
// 提取 ROI
imageROI= color(cv::Rect(0,0,100,45)); // 蓝色天空区域
```